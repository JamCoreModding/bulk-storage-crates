package io.github.jamalam360.bulk_storage_crates.content;

import io.github.jamalam360.bulk_storage_crates.BulkStorageCrates;
import net.minecraft.core.BlockPos;
import net.minecraft.util.Mth;
import net.minecraft.world.Containers;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.ItemInteractionResult;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.EntityBlock;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BooleanProperty;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraft.world.phys.shapes.BooleanOp;
import net.minecraft.world.phys.shapes.CollisionContext;
import net.minecraft.world.phys.shapes.Shapes;
import net.minecraft.world.phys.shapes.VoxelShape;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class CrateBlock extends Block implements EntityBlock {
	public static final BooleanProperty LIDDED = BooleanProperty.create("lidded");
	private static final VoxelShape LIDDED_SHAPE = Shapes.block();
	private static final VoxelShape UNLIDDED_SHAPE = makeUnliddedShape();
	private final int capacity;

	public CrateBlock(Block.Properties properties, int capacity) {
		super(properties);
		this.capacity = capacity;
		registerDefaultState(defaultBlockState().setValue(LIDDED, false));
	}

	@Override
	protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
		builder.add(LIDDED);
	}

	@Override
	protected @NotNull ItemInteractionResult useItemOn(ItemStack stack, BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hitResult) {
		if (stack.is(BulkStorageCrates.CROWBARS) && state.getValue(LIDDED)) {
			if (!level.isClientSide()) {
				level.setBlock(pos, state.setValue(LIDDED, false), Block.UPDATE_ALL);
				player.getInventory().placeItemBackInInventory(BulkStorageCrates.CRATE_LID.get().getDefaultInstance());
			}

			return ItemInteractionResult.sidedSuccess(level.isClientSide());
		} else if (stack.is(BulkStorageCrates.CRATE_LID.get()) && !state.getValue(LIDDED)) {
			if (!level.isClientSide()) {
				level.setBlock(pos, state.setValue(LIDDED, true), Block.UPDATE_ALL);
				player.getItemInHand(hand).setCount(player.getItemInHand(hand).getCount() - 1);
			}

			return ItemInteractionResult.sidedSuccess(level.isClientSide());
		} else if (!stack.is(BulkStorageCrates.CROWBARS) && !stack.is(BulkStorageCrates.CRATE_LID) && !state.getValue(LIDDED)) {
			if (level.getBlockEntity(pos) instanceof CrateBlockEntity entity) {
				if (!level.isClientSide()) {
					if (player.isCrouching() && stack.isEmpty()) {
						player.setItemInHand(hand, entity.removeStack());
					} else {
						player.setItemInHand(hand, entity.addStack(stack));
					}
				}

				return ItemInteractionResult.sidedSuccess(level.isClientSide());
			}
		}

		return ItemInteractionResult.FAIL;
	}

	protected @NotNull VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
		return state.getValue(LIDDED) ? LIDDED_SHAPE : UNLIDDED_SHAPE;
	}

	@Override
	public @Nullable BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
		return new CrateBlockEntity(pos, state, capacity);
	}

	protected void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean movedByPiston) {
		if (!state.is(newState.getBlock()) && level.getBlockEntity(pos) instanceof CrateBlockEntity entity) {
			for(int i = 0; i < entity.getItems().size(); i++) {
				Containers.dropItemStack(level, pos.getX(), pos.getY(), pos.getZ(), entity.getItems().get(i));
			}

			level.updateNeighbourForOutputSignal(pos, state.getBlock());
		}

		super.onRemove(state, level, pos, newState, movedByPiston);
	}

	protected boolean hasAnalogOutputSignal(BlockState state) {
		return true;
	}

	protected int getAnalogOutputSignal(BlockState state, Level level, BlockPos pos) {
		if (level.getBlockEntity(pos) instanceof CrateBlockEntity entity) {
			float f = 0.0F;

			for(int i = 0; i < entity.getItems().size(); ++i) {
				ItemStack stack = entity.getItems().get(i);
				if (!stack.isEmpty()) {
					f += (float)stack.getCount() / (float)stack.getMaxStackSize();
				}
			}

			f /= (float)entity.getItems().size();
			return Mth.lerpDiscrete(f, 0, 15);
		}

		return 0;
	}

	// Generated by block bench plugin
	private static VoxelShape makeUnliddedShape(){
		VoxelShape shape = Shapes.empty();
		shape = Shapes.join(shape, Shapes.box(0, 0, 0, 1, 0.0625, 1), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0, 0, 0, 1, 0.9375, 0.0625), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0, 0, 0.0625, 0.0625, 0.9375, 0.9375), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0.9375, 0, 0.0625, 1, 0.9375, 0.9375), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0, 0, 0.9375, 1, 0.9375, 1), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0.0625, 0.875, 0.0625, 0.125, 0.9375, 0.9375), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0.875, 0.875, 0.0625, 0.9375, 0.9375, 0.9375), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0.125, 0.875, 0.0625, 0.875, 0.9375, 0.125), BooleanOp.OR);
		shape = Shapes.join(shape, Shapes.box(0.125, 0.875, 0.875, 0.875, 0.9375, 0.9375), BooleanOp.OR);
		return shape;
	}
}
